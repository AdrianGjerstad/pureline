#!/bin/bash

# Based on: https://github.com/abhijitvalluri/bash-powerline-shell

# -----------------------------------------------------------------------------
# returns git branch name
# returns an empty string if not a git repository
function git_branch_name {
    local branch_name=$(git symbolic-ref HEAD 2> /dev/null)
    if [ ! -z "$branch_name" ]; then
        branch_name="${branch_name#refs/heads/}"
    fi
    echo "$branch_name"
}

# -----------------------------------------------------------------------------
# returns a string with the powerline symbol for a section end
# arg: $1 is background color of the next section
function section_end {
    local end_char=""
    if [ ! -z "$__last_color" ]; then
        echo "${colors[$__last_color]}${colors[On_$1]}$end_char"
    fi
}

# -----------------------------------------------------------------------------
# returns a string with background and foreground colours set
# arg: $1 foreground color
# arg: $2 background color
# arg: $3 content
function section_content {
    echo "${colors[$1]}${colors[On_$2]}$3"
}

# -----------------------------------------------------------------------------
# append to prompt: current time
function time_module {
    local bg_color="IBlack"
    local fg_color="White"
    PS1+=$(section_end $bg_color)
    PS1+=$(section_content $fg_color $bg_color " \t ")
    __last_color=$bg_color
}

# -----------------------------------------------------------------------------
# append to prompt: user@host
# optional rg: $1 - true/false to show the username
function host_module {
    local bg_color="Yellow"
    local fg_color="Black"
    if [ "$1" = true ]; then
        local content="\u@\h"
    else
        local content="\h"
    fi
    PS1+=$(section_end $bg_color)
    PS1+=$(section_content $fg_color $bg_color " $content ")
    __last_color=$bg_color
}

# -----------------------------------------------------------------------------
# append to prompt: current directory
function path_module {
    local bg_color="Blue"
    local fg_color="Black"
    PS1+=$(section_end $bg_color)
    PS1+=$(section_content $fg_color $bg_color " \W ")
    __last_color=$bg_color
}

# -----------------------------------------------------------------------------
# append to prompt: the number of background jobs running
function jobs_module {
    local bg_color="Purple"
    local fg_color="Black"
    local number_jobs=$(jobs -p | wc -l)
    if [ ! "$number_jobs" -eq 0 ]; then
        PS1+=$(section_end $bg_color)
        PS1+=$(section_content $fg_color $bg_color " ⏎$number_jobs ")
        __last_color=$bg_color
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: indicator is the current directory is ready-only
function read_only_module {
    local bg_color="Red"
    local fg_color="White"
    if [ ! -w "$PWD" ]; then
        PS1+=$(section_end $bg_color)
        PS1+=$(section_content $fg_color $bg_color "  ")
        __last_color=$bg_color
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: git branch with indictors for;
#     number of; modified files, staged files and conflicts
function git_module {
    local git_branch=$(git_branch_name)
    if [ ! -z "$git_branch" ]; then
        local number_modified=$(git diff --name-only --diff-filter=M | wc -l)
        if [ ! "$number_modified" -eq "0" ]; then
            number_modified=" ✚$number_modified"
        else
            number_modified=""
        fi
        local number_staged=$(git diff --staged --name-only --diff-filter=AM | wc -l)
        if [ ! "$number_staged" -eq "0" ]; then
            number_staged=" ✔$number_staged"
        else
            number_staged=""
        fi
        local number_conflicts=$(git diff --name-only --diff-filter=U | wc -l)
        if [ ! "$number_conflicts" -eq "0" ]; then
            number_conflicts=" ✘$number_conflicts"
        else
            number_conflicts=""
        fi
        local bg_color="Green"
        local fg_color="Black"
        local git_status="$number_modified $number_staged $number_conflicts "
        PS1+=$(section_end $bg_color)
        PS1+=$(section_content $fg_color $bg_color "  $git_branch $git_status")
        __last_color=$bg_color
    fi
}

# -----------------------------------------------------------------------------
# append to prompt: append a '$' prompt with optional return code for previous command
# optional arg: $1 - true/false to show return code
function prompt_module {
    if [ "$1" = true ] && [ ! "$return_code" -eq 0 ]; then
        local bg_color="Red"
        local fg_color="White"
        local content=" $ ⚑ $return_code "
    else
        local bg_color="IBlack"
        local fg_color="White"
        local content=" $ "
    fi
    PS1+=$(section_end $bg_color)
    PS1+=$(section_content $fg_color $bg_color "$content")
    __last_color=$bg_color
}

# -----------------------------------------------------------------------------
function powerline_prompt {
    return_code=$? # save return code
    PS1=""

    # Module list for the command prompt. Comment out those not needed.

    time_module
    host_module false       # Optional argument to show user name (true/false)
    path_module
    jobs_module
    read_only_module
    git_module
    prompt_module true      # Optional argument to show return codes (true/false)

    # Final end point
    if [ ! -z "$__last_color" ]; then
        PS1+=$(section_end)
    else
        PS1="$ "
    fi

    # Set the prompt and cleanup
    PS1+="${colors[Color_Off]} "
    unset __last_color
    unset return_code
}

# -----------------------------------------------------------------------------

# Get the relative path and import the color definitions
__script_dir=$( cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd -P )
source "$__script_dir/colors"

# Set the prompt command to dynamically set the PS1
PROMPT_COMMAND=powerline_prompt

