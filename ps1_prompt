#!/bin/bash

# Forked from https://github.com/abhijitvalluri/bash-powerline-shell

__script_dir=$( cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd -P )
source "$__script_dir/colors"

function git_branch_name {
    local branch_name=$(git symbolic-ref HEAD 2> /dev/null)
    if [ ! -z "$branch_name" ]; then
        branch_name="${branch_name#refs/heads/}"
    fi
    echo "$branch_name"
}

function ps1_powerline {
    local return_code=$? # save return code
    local number_jobs=$(jobs -p | wc -l)
    local git_branch=$(git_branch_name)

    local time_bg="IBlack"
    local time_fg="White"
    local host_bg="Yellow"
    local host_fg="Black"
    local path_bg="Blue"
    local path_fg="Black"
    local path_ro_bg="Red"
    local path_ro_fg="White"
    local jobs_bg="Purple"
    local jobs_fg="Black"
    local git_bg="Green"
    local git_fg="Black"
    local prompt_bg="IBlack"
    local prompt_fg="White"
    local ret_bg="Red"
    local ret_fg="White"

    local time_start="${colors[$time_fg]}${colors[On_$time_bg]} \t"
    local time_end="${colors[$time_bg]}${colors[On_$host_bg]}"

    local host_start="${colors[$host_fg]}${colors[On_$host_bg]}\u@\h"
    local host_end="${colors[$host_bg]}${colors[On_$path_bg]}"

    local path_start="${colors[$path_fg]}${colors[On_$path_bg]} \W"
    if [ -w "$PWD" ]; then
        # Current directory is writeable
        local path_end="${colors[$path_bg]}${colors[On_$git_bg]}"            # next segment is git
        local path_end_jobs="${colors[$path_bg]}${colors[On_$jobs_bg]}"      # next segment is jobs
        local path_end_alt="${colors[$path_bg]}${colors[On_$prompt_bg]}"     # next segment is prompt
        local path_end_ret="${colors[$path_bg]}${colors[On_$ret_bg]}"        # next segment is prompt with return code
    else
        # Current directory is not writable
        path_end="${colors[$path_bg]}${colors[On_$path_ro_bg]}"
        path_end+="${colors[$path_ro_fg]}${colors[On_$path_ro_bg]}  ${colors[$path_ro_bg]}${colors[On_$prompt_bg]}"

        path_end_jobs="${colors[$path_bg]}${colors[On_$path_ro_bg]}"
        path_end_jobs+="${colors[$path_ro_fg]}${colors[On_$path_ro_bg]}  ${colors[$path_ro_bg]}${colors[On_$jobs_bg]}"

        path_end_alt="${colors[$path_bg]}${colors[On_$path_ro_bg]}"
        path_end_alt+="${colors[$path_ro_fg]}${colors[On_$path_ro_bg]}  ${colors[$path_ro_bg]}${colors[On_$prompt_bg]}"

        path_end_ret="${colors[$path_bg]}${colors[On_$path_ro_bg]}"
        path_end_ret+="${colors[$path_ro_fg]}${colors[On_$path_ro_bg]}  "
    fi

    local jobs="${colors[$jobs_fg]}${colors[On_$jobs_bg]} ⏎"
    local jobs_end="${colors[jobs_bg]}${colors[On_$prompt_bg]}"          # next segment is prompt
    local jobs_no_ret_end="${colors[$jobs_bg]}${colors[On_$git_bg]}"      # next segment is git
    local jobs_no_git_end="${colors[$jobs_bg]}${colors[On_$ret_bg]}"      # next segment is prompt with return code

    local git_start="${colors[$git_fg]}${colors[On_$git_bg]} "
    local git_end="${colors[$git_bg]}${colors[On_$prompt_bg]}"           # next segment is prompt
    local git_end_ret="${colors[$git_bg]}${colors[On_$ret_bg]}"          # next segment is prompt with return code

    local ret="${colors[$ret_fg]}${colors[On_$ret_bg]}"
    local ret_end="${colors[Color_off]}${colors[$ret_bg]}${colors[Color_Off]}"

    local prompt="${colors[$prompt_fg]}${colors[On_$prompt_bg]}"
    local prompt_end="${colors[Color_Off]}${colors[$prompt_bg]}${colors[Color_Off]}"

    PS1="$time_start $time_end $host_start $host_end"

    if [ -z "$git_branch" ]; then
        # Is not a git repo
        if [ "$return_code" -eq 0 ]; then
            if [ "$number_jobs" -eq 0 ]; then
                # No jobs or ret code
                PS1+="$path_start $path_end_alt"
                PS1+="$prompt \$ $prompt_end"
            else
                # no ret code but jobs
                PS1+="$path_start $path_end_jobs"
                PS1+="$jobs$number_jobs $jobs_end"
                PS1+="$prompt \$ $prompt_end"
            fi
        else
            if [ "$number_jobs" -eq 0 ]; then
                # No jobs but ret code is there
                PS1+="$path_start $path_end_ret"
                PS1+="$ret \$ ⚑ $return_code $ret_end"
            else
                # Both jobs and ret code
                PS1+="$path_start $path_end_jobs"
                PS1+="$jobs$number_jobs $jobs_no_git_end"
                PS1+="$ret \$ ⚑ $return_code $ret_end"
            fi
        fi
    else
        # Is a git repo
        local number_modified=$(git diff --name-only --diff-filter=M | wc -l)
        if [ ! "$number_modified" -eq "0" ]; then
            number_modified="  ✚$number_modified"
        else
            number_modified=""
        fi
        local number_staged=$(git diff --staged --name-only --diff-filter=AM | wc -l)
        if [ ! "$number_staged" -eq "0" ]; then
            number_staged="  ✔$number_staged"
        else
            number_staged=""
        fi
        local number_conflicts=$(git diff --name-only --diff-filter=U | wc -l)
        if [ ! "$number_conflicts" -eq "0" ]; then
            number_conflicts="  ✘$number_conflicts"
        else
            number_conflicts=""
        fi
        local git_status="$number_modified$number_staged$number_conflicts "
        if [ "$return_code" -eq 0 ]; then
            git_status+=$git_end
        else
            git_status+=$git_end_ret
        fi

        if [ "$return_code" -eq 0 ]; then
            if [ "$number_jobs" -eq 0 ]; then
                # No jobs or ret code
                PS1+="$path_start $path_end"
                PS1+="$git_start $git_branch$git_status"
                PS1+="$prompt \$ $prompt_end"
            else
                # no ret code but jobs
                PS1+="$path_start $path_end_jobs"
                PS1+="$jobs$number_jobs $jobs_no_ret_end"
                PS1+="$git_start $git_branch $git_status"
                PS1+="$prompt \$ $prompt_end"
            fi
        else
            if [ "$number_jobs" -eq 0 ]; then
                # No jobs but ret code is there
                PS1+="$path_start $path_end"
                PS1+="$git_start $git_branch$git_status"
                PS1+="$ret \$ ⚑ $return_code $ret_end"
            else
                # Both jobs and ret code
                PS1+="$path_start $path_end_jobs"
                PS1+="$jobs$number_jobs $jobs_no_ret_end"
                PS1+="$git_start $git_branch$git_status"
                PS1+="$ret \$ ⚑ $return_code $ret_end"
            fi
        fi

    fi
    PS1+=" "
}
PROMPT_COMMAND=ps1_powerline